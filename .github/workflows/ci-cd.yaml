# .github/workflows/ci-cd.yaml
name: KubeCart CI/CD Pipeline

# Trigger the workflow on pushes to the main branch
on:
  push:
    branches:
      - main
  # Allow manual runs from the GitHub Actions tab
  workflow_dispatch:

env:
  # Base name for the image (matches your Docker Hub name)
  IMAGE_NAME: product-catalog-service 
  # Use the GitHub Run ID as a unique tag
  TAG: ${{ github.run_id }} 
  DOCKER_USER: ${{ secrets.DOCKER_USERNAME }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: ‚¨áÔ∏è Checkout Repository
        uses: actions/checkout@v4

      # --- 1. Log in to Docker Hub ---
      - name: üîë Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
          
      # --- 2. Build the Docker Image ---
      - name: üî® Build Docker Image
        # Note: 'context' is where the Dockerfile is located. Assuming it's in the repo root.
        # If your Dockerfile is in a subdirectory (e.g., 'services/product-catalog'), adjust the 'context'.
        # We use a combined tag format: starrider315/product-catalog-service:latest and :run_id
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
            ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:${{ env.TAG }}

      # --- 3. Update Kubernetes Manifests (Optional but Recommended) ---
      # This step updates the YAML to use the new image tag before deploying
      - name: üìù Update K8s Manifest with New Image Tag
        uses: fjogeleit/yaml-update-action@main
        with:
          value: ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:${{ env.TAG }}
          propertyPath: "spec.template.spec.containers[0].image"
          filePath: "kubernetes/manifests/KubeCart.yaml" # Adjust path to your file
          commitChange: true

  # ----------------------------------------------------
  # --- Kubernetes Deployment Job (Basic Example) ---
  # ----------------------------------------------------
  deploy:
    needs: build-and-push # Ensures build must succeed first
    runs-on: ubuntu-latest
    
    # This step is highly dependent on your cluster environment. 
    # This example assumes you have a way to securely connect your runner to KubeCart.
    steps:
      - name: ‚¨áÔ∏è Checkout Repository
        uses: actions/checkout@v4
        
      - name: üöÄ Deploy to Kubernetes (using kubectl)
        # Note: For actual deployment, you would typically use a dedicated action
        # for your cloud provider (e.g., Google GKE, AWS EKS, Azure AKS) or 
        # use a secret for your KubeConfig.
        run: |
          # The following is a placeholder command for deployment:
          # In a real environment, you'd configure kubectl access first.
          echo "Simulating deployment using kubectl apply..."
          # kubectl apply -f kubernetes/manifests/
          
          # Since we updated the YAML file in the previous job and committed, 
          # you can use that updated YAML to deploy.
          echo "Deployment complete for ${{ env.IMAGE_NAME }}:${{ env.TAG }}"